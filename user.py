# -*- encoding: utf-8 -*-
import stackless
import urllib2, urllib
import socket
import struct 
import time,random
import logging

import settings 
import context

RLOG = logging.getLogger('runlog')

    

class User(object):

  def __init__(self,name, password):
    self.name = name
    self.password = password
    self.id = None # user id
    self.sid = None #session id
    self.arena=None #当前所在的arena ID
    self.sock = None #socket 连接
    self.ready = False
    self.switch = True #事务流程开关
    self.errorlist = {}
    self.packs = []
    
  def login(self):
    """登陆msg服务器""" #________没有发现http请求
    self.sock = socket.socket()
    self.sock.connect(settings.MSG_SVR)
    
    from protobuf.soc_login_pb2 import SocketLoginMessage
    msg = SocketLoginMessage()
    msg.code=1 #________？
    msg.userName = self.name
    msg.password = self.password
    msg_data = msg.SerializeToString()
    #print msg_data #________
    
    #TODO: 网络错误处理
    len_msg_data = len(msg_data)
    d=struct.pack("<HIHHI%ss"%len_msg_data,
      len_msg_data + 12,
      0xABDE, # magic code
      len_msg_data + 12,
      0x9001, # 9001 表示flash请求，9002是相应
      0,
      msg_data)
    stackless.tasklet(self._network_receive_package)()
    t=self.sock.send(d);

    from protobuf.res_base_pb2 import Response
    self._tasklet_receive_package()
    cmd, payload = self.packs[0]
    del self.packs[0]
    
    pbr = Response()
    pbr.ParseFromString(payload) #将bit流解析为对象
    if self._check_pb_response_ok(pbr): 
      self.sid = pbr.userTCPLogin.sid
      self.id = pbr.userTCPLogin.uid
      RLOG.debug("user %s_%s login"%(self.name,self.id))
      
      #receive one unknow package then discard it, generated by Message Server
      self._tasklet_receive_package()
      c,p = self.packs[0] #接收怎样登录的信息(是否T别人登录)
      del self.packs[0]
      
      
    else:
      #TODO: proto 解析失败的处理
      RLOG.error("LOGIN ERROR %s"%pbr)
    stackless.tasklet(self._listen_messages)()
    
      
  def _network_receive_package(self):
      """按照msg server的协议，接收一个数据包。
                返回值是命令码和负载数据"""
      self.pack_ch = stackless.channel()
      while self.switch:
          self.pack_ch.send(self.sock.recv(2048))
          
  def _tasklet_receive_package(self):
      pkg = ''
      while True:
          pkg += self.pack_ch.receive()
          pkg = self._package_parse(pkg)
          if not pkg:
              break

  def _package_parse(self, pkg):
    package = pkg
    if len(package) >= 2: #小于数据包长度标示符
      l = struct.unpack("<H", package[:2])[0]
      if len(package) >= (l + 2): #此包是否完整
        raw_package = package[:l+2]
        package=package[l+2:]
        packagelist = struct.unpack("<HIHHI%ss"%(l-12), raw_package)
        #TODO: 检查返回数据的格式
        self.packs.append([packagelist[3], packagelist[5]])
        package = self._package_parse(package)
    return package
  
#===============================================================================
#    package = None
#    flag = True
#    while flag:
#      pkg = self.pack_ch.receive()
#      received_data += pkg
#      if len(received_data) == 0:
#        raise Exception("connection closed")
#        break
#      while True:
#        if len(received_data) >= 2: #小于数据包长度标示符
#          l = struct.unpack("<H", received_data[:2])[0]
#          if len(received_data) >= (l + 2):
#            raw_package = received_data[:l+2]
#            received_data=received_data[l+2:]
#            package = struct.unpack("<HIHHI%ss"%(l-12), raw_package)
#            #TODO: 检查返回数据的格式
#            self.packs.append([package[3], package[5]])
#          else:
#            flag = True
#            break
#        elif len(received_data):
#          flag = True
#          break
#        else:
#          flag = False
#          break
#===============================================================================
  
  def _listen_messages(self):
    """循环监听消息"""
    from protobuf.msg_base_pb2 import Msg
    while True:
      self._tasklet_receive_package()
      for package in self.packs:
        cmd, payload=package
        if cmd==0x9003:
          msg = Msg()
          msg.ParseFromString(payload)
          if msg.code == 0x2301:
            self.on_arenaJoined(msg)
          elif msg.code == 0x2302:
            self.on_arenaLeaved(msg)
          elif msg.code == 0x230b:
            self.on_arenaStart(msg)
          elif msg.code == 0x230d:
            self.on_arenaEnded(msg)
          elif msg.code ==0x2305:
            self.on_arenaMemberUpdated(msg)
          else:
            pass
        else:
          hex_text = "".join(["%02X "%ord(c) for c in payload])
          RLOG.error("unknow package received %s %s"%(cmd, hex_text))
      self.packs=[]
    
  def _make_url(self, req):
    """组合URL，连接JAVA写的APP服务器"""
    return "http://%s:%s/app3/%s?alt=pbbin"%(
      settings.ARENA_SVR[0],
      settings.ARENA_SVR[1],
      req,
      )

  def _py_make_url(self, req):
    """组合URL，连接PYTHON写的APP服务器"""
    return "http://%s:%s/campus/api/%s?alt=pbbin"%(
      settings.PY_SVR[0],
      settings.PY_SVR[1],
      req,
      )
  
  def _check_pb_response_ok(self, pb):
    """检查返回的probobuf结果是否正常"""
    if pb.code/100000 == 2:
        return True
    else:
        self.errorlist[str(self.name) + '_' + str(self.id)]=pb.code
        print self.errorlist
        return False
    
  def _send_request(self, partial_url, data=None):
    """发送请求，解析结果，错误处理, 返回pb"""
    if data is not None:
      data = urllib.urlencode(data)
    ptime = time.strftime('%Y-%m-%d %H:%M:%S',time.gmtime())
    stime = time.time()
    r = urllib2.urlopen(self._make_url(partial_url), data)
    etime = time.time()
    d=r.read()
    #TODO: 处理HTTP错误
    from protobuf.res_base_pb2 import Response
    pbr=Response()
    pbr.ParseFromString(d)
    return {'mtime' : etime - stime, 
            'ptime' : ptime, 
            'data' : pbr,
            }

  def _sleep(self, seconds):
    """休息，休息一会儿"""
    context.delay_service.delay_caller(seconds)
    
  ##########################################################################
  # 用户行为
  ##########################################################################
    
  def do(self, ch):
    """开始工作"""
    #random sleep for a while
    self.ch = ch
    st = random.random()*settings.USER_RANDOM_SLEEP_TIME
    self._sleep(st)
    self.login()
    #self.switch = 0 #用来判定上场游戏结束后是否退出arena
    self.list_arena()

  def list_arena(self):
    """获取arena列表，如果有房间就加入，没有房间就创建一个等人进"""
    rps = self._send_request("events/2/list")
    self.ch.send(['rsptime', ['list_arena', 
                              rps['ptime'], 
                              rps['mtime']]])
    r = rps['data']
    if (self._check_pb_response_ok(r)):
      #没满的房间
      rooms = [i for i in r.ca03ArenaList.items if i.mcount.split("/")[0] != i.mcount.split("/")[1]]
      n = len(rooms)
      if (n==0):
        self.create_arena()
      else:
        #随机找一个
        a = random.sample(rooms,1)
        self.enter_arena(a[0].id)
    else:
      RLOG.error("list_arena_%s_%sRESPONSE ERROR: %s"%(self.name,self.id, r))
      self.ch.send(['error', ['list_arena', 
                              rps['ptime'], 
                              r.code]])
      #self.list_arena()
    
  def create_arena(self):
    """创建房间"""
    #print self.id
    rps=self._send_request("events/2/create", 
                           {"userid":self.id, 
                           "mode":"rd", 
                           "private":"false",
                           }
                          )
    self.ch.send(['rsptime', ['create_arena', 
                              rps['ptime'], 
                              rps['mtime']]])
    r = rps['data']
    if (self._check_pb_response_ok(r)):
      #print "DEBUG", "arena created"
      pass
    else:
      RLOG.error("create_arena_%s_%sRESPONSE ERROR: %s"%(self.name, self.id, r))
      #self.list_arena()

  def enter_arena(self, arena_id):
    """加入一个房间"""
    rps=self._send_request("arenas/%s/enter"%arena_id, {"userid":self.id})
    self.ch.send(['rsptime', ['enter_arena', 
                              rps['ptime'], 
                              rps['mtime']]])
    r = rps['data']
    if (self._check_pb_response_ok(r)):
      print "DEBUG", "enter arena %s"%arena_id
      pass
    else:
      if r.code == 419004:
        # arena is full
        self.list_arena()
      elif r.code/1000 == 404:
        # arena does not exist
        self.list_arena()
      elif r.code/1000 == 403:
        # arena has begin
        self.list_arena()
      else:
        RLOG.error("enter_arena_%s_%sRESPONSE ERROR: %s"%(self.name, self.id, r))    
       
  def make_ready(self):
    """准备"""
    assert self.arena is not None
    rps=self._send_request("arenas/%s/ready"%self.arena, {"userid":self.id})
    self.ch.send(['rsptime', ['make_ready', 
                              rps['ptime'], 
                              rps['mtime']]])
    r = rps['data']
    if (self._check_pb_response_ok(r)):
      RLOG.debug("%s_%s ready"%(self.name,self.id))
    else:
      RLOG.error("make_ready_%s_%sRESPONSE ERROR: %s"%(self.name, self.id, r))
      #self.leave_arena()
      #TODO: 处理各种失败，包括人不在Arena, arena已经开始等等异常。不重要，可以不做。
      
  def leave_arena(self):
    """离开房间"""
    assert self.arena is not None
    rps=self._send_request("arenas/%s/leave"%self.arena, {"userid":self.id})
    self.ch.send(['rsptime', ['leave_arena', 
                              rps['ptime'], 
                              rps['mtime']]])
    r = rps['data']
    if (self._check_pb_response_ok(r)):
      RLOG.debug("%s_%s leaving arena %s"%(self.name, self.id, self.arena))
    else:
      RLOG.error("leave_arena_%s_%sRESPONSE ERROR: %s"%(self.name, self.id, r))
    
  def start_game(self): #5
    """开始游戏"""
    assert self.arena is not None
    rps=self._send_request("arenas/%s/start"%self.arena, {"userid":self.id})
    self.ch.send(['rsptime', ['start_game', 
                              rps['ptime'], 
                              rps['mtime']]])
    r = rps['data']
    if (self._check_pb_response_ok(r)):
      RLOG.debug("%s_%s start arena %s"%(self.name, self.id, self.arena))
    else:
      if (r.code == 403000):
        #not in this arena or not the leader or has started, just ignore this action
        pass
      elif(r.code/1000 == 419):
        #someone in the arena is not ready or offline or they all sit at the  same side.
        pass
      else:
        RLOG.error("start_game_%s_%sRESPONSE ERROR: %s"%(self.name, self.id, r))
      #self.leave_arena()
    
  def submit_result(self):
    """提交游戏结果"""
    assert self.arena is not None
    rps=self._send_request("arenas/%s/submit_result"%self.arena, {"userid":self.id, "result":context.game_result})
    self.ch.send(['rsptime', ['submit_result', 
                              rps['ptime'], 
                              rps['mtime']]])
    r = rps['data']
    if (self._check_pb_response_ok(r)):
      RLOG.debug("%s_%s submit game result"%(self.name, self.id))
    else:
      if r.code == 403000:
        pass
        
      else:
        RLOG.error("submit_result_%s_%sRESPONSE ERROR: %s"%(self.name, self.id, r))
      #self.leave_arena()

  def logout(self):
      rps=self._py_send_request("user.tcplogout", {"sid":self.sid})
      self.ch.send(['tsptime', ['logout', 
                                rps['ptime'], 
                                rps['mtime']]])
      r = rps['data']
      if (self._check_pb_response_ok(r)):
          RLOG.debug("%s_%s logout"%(self.name, self.id))
      else:
          RLOG.error("logout_%s_%sRESPONSE ERROR: %s"%(self.name, self.id, r))
      self.switch
      self.pack_ch.close()
      self.sock.close()
    
  ##########################################################################
  # 消息处理
  ##########################################################################
    
  def on_arenaJoined(self, msg):
    """我加入了一个房间"""
    self.arena = msg.arenaJoined.arena.id
    RLOG.debug("%s_%s arena joined %s"%(self.name, self.id, self.arena))
    self._sleep(random.randrange(1,settings.BEFORE_READY))
    self.make_ready()
    #print "trying ready"
    
  def on_arenaLeaved(self, msg):
    """我离开了一个房间"""
    RLOG.debug("%s_%s leaved arena %s"%(self.name, self.id, self.arena))
    self.arena = None
    self._sleep(random.randrange(1,settings.BEFORE_LISTARENA))
    self.list_arena()
    
  def on_arenaMemberUpdated(self, msg):
    """用户状态更新，包括自己"""
    if msg.arenaMemberUpdated.userID == self.id and msg.arenaMemberUpdated.arenaID==self.arena:
      #Ready
      if msg.arenaMemberUpdated.ready is not None:
        self.ready = msg.arenaMemberUpdated.ready
      
      #当自己有开始权限的时候，就开始
      if "start" in msg.arenaMemberUpdated.actions:
        from control import Control
        Control().exit()
        self.start_game()
  
  def on_arenaStart(self, msg):
    """游戏开始"""
    #self._sleep(random.randrange(1,settings.BEFORE_SUBRESULT))
    self._sleep(settings.BEFORE_SUBRESULT)
    self.submit_result()
  
  def on_arenaEnded(self, msg):
    """游戏结束"""
    RLOG.debug("%s arena is end"%self.arena)
    self._sleep(random.random()*settings.USER_RANDOM_SLEEP_TIME)
    self.leave_arena()
    
    #rno = random.randrange(1,3)
    #if rno % 2 == 0:
    #  self.leave_arena()
    #else:
    #  self.make_ready()