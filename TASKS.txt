Meeting 2
=============
Due Date: 9:00 AM, Oct. 11 2010

1. 阅读user.py中的用户行为模型代码

  public方法：
    .do() 入口方法，User开始行动。
    .login() 登陆message server
    .enter_arena() 加入房间
    .leave_arena() 离开房间
    ......
    
  private方法：
    都是以下划线开头
    
  消息处理函数：
    都是以on_开头
    
2. 补充完成用户行为循环
                                        |Y-进入房间 ->等待开始     |
  用户登陆->读取房间列表->有空余的房间？|N-创建房间 ->等待人满开始 | -> 等待1分钟(相当于打了一分钟游戏) -> 发送游戏结果 -> 接收到游戏结束 -> 1/2的人留在房间里继续，1/2的人离开房间，休息一会儿，再次读取房间列表
  
  1) 完成enter_arena函数的错误处理。错误代码如下：
    
      Arena已满 419004 
      其他      XXXXXX
      
  2) 开始游戏，发送结果
   
    房主开始游戏: 地址 arenas/<arena id>/start  参数userid, 
    游戏开始消息: arenaStart
    发送结果: 我已经实现, 没测试，假的。
    
    
  3) 处理游戏结束消息, 并作出后续决定
  
    游戏结束消息： arenaEnded
    离开房间请求： arenas/<arena id>/leave 参数userid
  
Meeting 1
==============
Date: 2010-10-13

1. code review
 1.1 解决comments， 解决其他疑问
 1.2 enter_arena 的错误处理？clear
 1.3 _receive_package
   * self.sock.rece() 最好只调用一次 clear
 1.4 发送http请求的过程中，程序会卡死吗？不会阻塞其他人，只会阻塞发请求的人自己。
 1.5 如何修改，让发送请求和接收消息能够“同时”运行？channle
     生产者消费者模型，他们之间用队列/管道来通信。

2. stackless python
 2.1 microthread, 微线程，纤程，用户线程，tasklet
 2.2 scheduler
 2.3 channel，就是管道(pipe), 可以独立使用
 2.4 正确的尾调用
    def f1():
       if xxxx:
         f2()
       else:
         f3()
    def f2():
       f()

 2.5 问题：1. 缺少调试工具 2. 缺少异步库的支持


TAST 2
=========
时间统计

记录下

每个操作请求，到收到成功相应的时间
每个操作请求，到收到期望的消息的时间

记录到内存里，然后再想办法统计


TASK 3
============
更灵活的配置


1. test fixture 运行时可选的加载配置文件
  1.1 用户账号
  1.2 单次运行 还是 循环运行
  1.3 一场游戏的时间

2. 也许是这样的效果

python main.py 20users loop 就表示加载20个用户，持续循环。
python main.py 6users noloop 就表示只加载6个用户，用户就打一次游戏。

3. 也可以是命令行形式

python main.py
gm> set_user 20users
gm> set_loop true
gm> run
gm> stop

TASK 4
========
change protobuf 2.1.0 to protobuf 2.3.0

TASK 5
============
如何修改，让发送请求和接收消息能够“同时”运行？
